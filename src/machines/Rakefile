# frozen_string_literal: true

require 'yaml'
require 'forwardable'
require 'open-uri'

# Helpers

# :reek:UtilityFunction

# Serialize verbose environment variable
def verbose?
  case ENV['verbose']
  when 'true', 'yes', 'on' then true
  when 'false', 'no', 'off' then false
  else false
  end
end

# Given arrays have no element in common?
def disjoint_arrays?(*arrays)
  require 'set'
  arrays.map { |array| Set.new(array) }
        .combination(2).all? { |left, right| left.disjoint? right }
end

# Signal bugs
def bug(message)
  abort "BUG: #{message}"
end

# Manage supported data
module Supported
  FILE     = 'supported.yml'
  TEMPLATE = {
    images: %i[
      distribution
      suite
      codename
      arch
      iso_checksum
      iso_checksum_type
      iso_checksum_url
      iso_url
      skip
      only
      except
    ],
    medleys: %i[
      medley
      medley_url
    ]
  }.freeze

  class << self
    # :reek:Attribute
    attr_accessor :images, :medleys
  end

  # Image data
  Image = Struct.new(*TEMPLATE[:images], keyword_init: true)
  # Image extras
  class Image
    TEMPLATE_FILE = 'template.json'

    # :reek:TooManyStatements { max_statements: 6 }
    def self.images(supported)
      supported['images'].map do |hash|
        new(hash).sanitize
      rescue ArgumentError => err
        abort "Error loading image from YAML: #{err}"
      rescue ImageError => err
        warn err
      end.compact.reject(&:skip?)
    end

    # :reek:NilCheck
    def new_iso_checksum
      path = iso_url.sub(%r{^#{File.dirname(iso_checksum_url)}/*}, '')
      URI.open(iso_checksum_url).readlines.map(&:chomp).detect do |line|
        line =~ /#{path}$/
      end&.split&.first
    rescue OpenURI::HTTPError => err
      abort "Error fetching #{iso_checksum_url}: #{err}"
    end

    def directory
      distribution.to_s
    end

    def template
      TEMPLATE_FILE
    end

    def preseed
      "#{codename}.cfg"
    end

    def skip?
      skip
    end

    def sanitize
      error 'Distribution directory missing' unless File.directory?(directory)
      unless File.exist?(File.join(directory, template))
        error 'Packer template missing'
      end
      unless File.exist?(File.join(directory, preseed))
        error "Preseed file for #{suite} missing"
      end
      self
    end

    def to_h
      hash = super
      hash.merge! directory: directory, template: template, preseed: preseed
      hash
    end

    private

    # Image error
    class ImageError < StandardError; end

    def error(message)
      raise ImageError, "E: #{message}: #{distribution}"
    end
  end

  # Medley data
  Medley = Struct.new(*TEMPLATE[:medleys], keyword_init: true)
  # Medley extras
  class Medley
    def self.medleys(supported)
      supported['medleys'].map do |hash|
        new(hash)
      rescue ArgumentError => err
        abort "Error loading medley from YAML: #{err}"
      end
    end
  end

  def self.boxes
    images.product(medleys).map { |data| Box.new(*data) }
  end

  def self.support
    supported    = YAML.safe_load(File.read(FILE), [], [], true)
    self.images  = Image.images supported
    self.medleys = Medley.medleys supported
  end

  support
end

# Box data
class Box
  def initialize(image_data, medley_data)
    @image_data  = image_data
    @medley_data = medley_data
  end

  def boxname(prefix = nil)
    name_build '-', prefix
  end

  def taskname(prefix = nil)
    name_build ':', prefix
  end

  def hostname
    medley
  end

  # We are about to use delegation.  Ensure that no attribute defined so far,
  # will be overwritten.

  extend Forwardable

  image_attributes  = Supported::Image.public_instance_methods(false)
  medley_attributes = Supported::Medley.public_instance_methods(false)

  # Note the methods defined so far, which we don't want to be overwritten.
  SELF_ATTRIBUTES   = public_instance_methods(false)

  unless disjoint_arrays?(image_attributes, medley_attributes, SELF_ATTRIBUTES)
    bug 'Image, Medley and Box must have no attributes in common'
  end

  def_delegators :@image_data,  *image_attributes
  def_delegators :@medley_data, *medley_attributes

  # No overwrite protection from here.

  def to_h
    hash = Hash[*SELF_ATTRIBUTES.map { |attr| [attr, send(attr)] }.flatten]
    hash.merge! image_data.to_h
    hash.merge! medley_data.to_h
    hash
  end

  def to_s
    boxname
  end

  def ok?
    return only.include?(medley) if only
    return !except.include?(medley) if except
    true
  end

  private

  attr_reader :image_data, :medley_data

  def name_build(separator, prefix = nil)
    [prefix, distribution, suite, medley].compact.join separator
  end
end

# Packer wrapper
class Packer
  include FileUtils

  def self.run(box, command)
    Dir.chdir(box.directory) do
      warn format("\x1b[36;01m%<command>-8s\x1b[0m %<name>s",
                  command: command, name: box.taskname)
      new(box).send command
    end
  end

  def initialize(box)
    @box = box
  end

  BUILD_FLAGS =
    %w[-force -parallel=false] +
    if ENV['production']
      %w[-var=headless=true']
    else
      %w[-var='headless=false' -on-error=ask]
    end

  def build
    cmd  = cmdline('build', *BUILD_FLAGS)
    cmd += " | tee -a '#{box.boxname}.log'"
    sh cmd, verbose: verbose? do |ok, _|
      warn "#{cmd} failed; proceeding anyway" unless ok
    end
  end

  def validate
    sh cmdline('validate'), verbose: verbose?
  end

  def clean
    rm_rf ["#{box.boxname}.box", "#{box.boxname}.log", *Dir.glob('output-*')]
  end

  private

  attr_reader :box

  def cmdline(command, *extra_flags)
    args  = ['packer', command, *vars, *flags]
    args += extra_flags
    args += [template]
    args.join ' '
  end

  # :reek:UtilityFunction
  def flags
    flags = []

    %w[only except].each do |flag|
      next unless (value = ENV[flag])
      flags += %W[-#{flag}=#{value}]
    end

    flags
  end

  def vars
    box.to_h.map { |variable, value| "-var='#{variable}=#{value}'" }
  end

  def template
    box.template
  end
end

Supported.boxes.select(&:ok?).each do |box|
  Packer.instance_methods(false).each do |command|
    namespace command do
      namespace box.distribution do
        namespace(box.suite) do
          desc "#{command} #{box} box"
          task(box.medley) { Packer.run(box, command) }
        end

        desc "#{command} all #{box.distribution}:#{box.suite} boxes"
        task box.suite
      end

      desc "#{command} all #{box.distribution} boxes"
      task box.distribution
    end

    desc "#{command} all boxes"
    task command

    enhancements = {}

    %W[
      #{command}
      #{command}:#{box.distribution}
      #{command}:#{box.distribution}:#{box.suite}
    ].each do |enhancement|
      next unless Rake::Task.task_defined? enhancement
      (enhancements[enhancement.to_s] = []) << box.taskname(command).to_s
    end

    enhancements.keys.sort.each do |enhancement|
      Rake::Task[enhancement].enhance enhancements[enhancement].sort
    end
  end
end

desc 'Update checksums'
task :checksum do
  content = File.read(Supported::FILE)
  nchange = 0
  warn 'Fetching checksums...'
  Supported.images.each do |image|
    iso_url = image.iso_url
    unless (new_checksum = image.new_iso_checksum)
      warn "Checksum calculation failed for: #{iso_url}"
      next
    end
    next if (old_checksum = image.iso_checksum) == new_checksum
    content.sub! old_checksum, new_checksum
    warn "Checksum changed: #{iso_url}"
    nchange += 1
  end
  if nchange.positive?
    File.write(Supported::FILE, content)
  else
    warn 'Checksums unchanged'
  end
end

desc 'clobber all'
task :clobber do
  sh %w[git clean -fdx -e .envrc]
end
